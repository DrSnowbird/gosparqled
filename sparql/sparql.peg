# SPARQL grammar

package sparql

type Sparql Peg {
}

queryContainer <- skip prolog query !.

prolog <- ( prefixDecl / baseDecl )*

prefixDecl <- PREFIX [^: ]* COLON iri

baseDecl <- BASE iri

query <- selectQuery / constructQuery / describeQuery / askQuery
selectQuery <- select datasetClause? whereClause solutionModifier
select <- SELECT ( DISTINCT / REDUCED )? ( STAR / projectionElem+ )
subSelect <- select whereClause
constructQuery <- construct datasetClause? whereClause solutionModifier
construct <- CONSTRUCT LBRACE triplesBlock? RBRACE
describeQuery <- describe datasetClause? whereClause? solutionModifier
describe <- DESCRIBE ( STAR / var / iriref )
askQuery <- ASK datasetClause? whereClause

projectionElem <- var / LPAREN expression AS var RPAREN

datasetClause <- FROM NAMED? iriref

whereClause <- WHERE? groupGraphPattern

groupGraphPattern <- LBRACE ( subSelect / graphPattern ) RBRACE

graphPattern <- basicGraphPattern? ( graphPatternNotTriples DOT? graphPattern )?

graphPatternNotTriples <- optionalGraphPattern / groupOrUnionGraphPattern

optionalGraphPattern <- OPTIONAL LBRACE ( subSelect / graphPattern ) RBRACE

groupOrUnionGraphPattern <- groupGraphPattern ( UNION groupOrUnionGraphPattern )?

basicGraphPattern <- triplesBlock

triplesBlock <- triplesSameSubjectPath ( DOT triplesSameSubjectPath )* DOT?

triplesSameSubjectPath <- ( varOrTerm propertyListPath / triplesNodePath propertyListPath )

varOrTerm <- var / graphTerm

graphTerm <- iriref / literal / numericLiteral / booleanLiteral / blankNode / nil

triplesNodePath <- collectionPath / blankNodePropertyListPath

collectionPath <- LPAREN graphNodePath+ RPAREN

blankNodePropertyListPath <- LBRACK propertyListPath RBRACK

propertyListPath <- ( var / verbPath ) objectListPath ( SEMICOLON propertyListPath )?

verbPath <- path

path <- pathAlternative

pathAlternative <- pathSequence ( PIPE pathAlternative )*

pathSequence <- pathElt ( SLASH pathSequence )*

# TODO: support pathmod rule.
pathElt <- INVERSE? pathPrimary #pathMod?

pathPrimary <- iriref / ISA / NOT pathNegatedPropertySet / LPAREN path RPAREN

pathNegatedPropertySet <- pathOneInPropertySet / LPAREN ( pathOneInPropertySet ( PIPE pathOneInPropertySet )* )? RPAREN

pathOneInPropertySet <- iriref / ISA / INVERSE ( iriref / ISA )

#pathMod <- STAR / QUESTION / PLUS

objectListPath <- objectPath ( COMMA objectListPath )*

objectPath <- graphNodePath

graphNodePath <- varOrTerm

solutionModifier <- limitOffsetClauses?

limitOffsetClauses <- limit offset? / offset limit?

limit <- LIMIT INTEGER

offset <- OFFSET INTEGER

# Expressions

expression <- conditionalOrExpression
conditionalOrExpression <- conditionalAndExpression ( OR conditionalOrExpression )?
conditionalAndExpression <- valueLogical ( AND conditionalAndExpression )?
valueLogical <- numericExpression ( ( EQ / NE / LT / LE / GE / GT ) numericExpression / in / notin )?
numericExpression <- multiplicativeExpression ( ( PLUS / MINUS ) multiplicativeExpression / signedNumericLiteral )*
multiplicativeExpression <- unaryExpression ( ( STAR / SLASH ) unaryExpression )*
unaryExpression <- ( NOT / MINUS / PLUS )? primaryExpression
primaryExpression <- brackettedExpression / builtinCall / functionCall / iriref / literal / numericLiteral / booleanLiteral / var
brackettedExpression <- LPAREN expression RPAREN
functionCall <- iriref argList

in <- IN argList
notin <- NOTIN argList

argList <- nil / LPAREN expression ( COMMA expression )* RPAREN

builtinCall <- (
                STR /
                LANG /
                DATATYPE /
                IRI /
                URI /
                ABS /
                CEIL /
                ROUND /
                FLOOR /
                STRLEN /
                UCASE /
                LCASE /
                ENCODEFORURI /
                YEAR /
                MONTH /
                DAY /
                HOURS /
                MINUTES /
                SECONDS /
                TIMEZONE /
                TZ /
                MD5 /
                SHA1 /
                SHA256 /
                SHA384 /
                SHA512 /
                ISIRI /
                ISURI /
                ISBLANK /
                ISLITERAL /
                ISNUMERIC
               ) LPAREN expression RPAREN /
               (
                LANGMATCHES /
                CONTAINS /
                STRSTARTS /
                STRENDS /
                STRBEFORE /
                STRAFTER /
                STRLANG /
                STRDT /
                SAMETERM
               ) LPAREN expression COMMA expression RPAREN /
               BOUND LPAREN var RPAREN /
               BNODE ( LPAREN expression RPAREN / nil ) /
               ( RAND / NOW / UUID / STRUUID ) nil /
               ( CONCAT / COALESCE ) argList /
               ( SUBSTR / REPLACE / REGEX ) LPAREN expression COMMA expression ( COMMA expression )? RPAREN /
               IF LPAREN expression COMMA expression COMMA expression RPAREN /
               ( EXISTS / NOTEXIST ) groupGraphPattern

#
# Terminals
#

var <- ('?' / '$') VARNAME skip

iriref <- iri / prefixedName

iri <- '<' [^>]* '>' skip

prefixedName <- [^: ]* ':' [a-zA-Z0-9.-_:%]* skip

literal <- string ( '@' [[a-z]]+ ('-' ([[a-z]] / [0-9])+)* / "^^" iriref )? skip

string <- '\"' [^"]* '\"'

numericLiteral <- ('+' / '-')? [0-9]+ ('.' [0-9]*)? skip
signedNumericLiteral <- ('+' / '-') [0-9]+ ('.' [0-9]*)? skip

booleanLiteral <- TRUE / FALSE

blankNode <- blankNodeLabel / anon

blankNodeLabel <- "_:" [a-zA-Z0-9][a-zA-Z0-9.-_] ?skip

anon <- '[' ws* ']' skip

nil <- '(' ws* ')' skip

#
# Labels
#

VARNAME <- ( PN_CHARS_U / [0-9] )+ 
PN_CHARS_U <- PN_CHARS_BASE / '_'
PN_CHARS_BASE <- [[a-z]]

#
# Tokens
#

PREFIX <- "PREFIX" skip
TRUE <- "TRUE" skip
FALSE <- "FALSE" skip
BASE <- "BASE" skip
SELECT <- "SELECT" skip
REDUCED <- "REDUCED" skip
DISTINCT <- "DISTINCT" skip
FROM <- "FROM" skip
NAMED <- "NAMED" skip
WHERE <- "WHERE" skip
LBRACE <- '{' skip
RBRACE <- '}' skip
LBRACK <- '[' skip
RBRACK <- ']' skip
SEMICOLON <- ';' skip
COMMA <- ',' skip
DOT <- '.' skip
COLON <- ':' skip
PIPE <- '|' skip
SLASH <- '/' skip
INVERSE <- '^' skip
LPAREN <- '(' skip
RPAREN <- ')' skip
ISA <- 'a' skip
NOT <- '!' skip
STAR <- '*' skip
#QUESTION <- '?' skip
PLUS <- '+' skip
MINUS <- '-' skip
OPTIONAL <- "OPTIONAL" skip
UNION <- "UNION" skip
LIMIT <- "LIMIT" skip
OFFSET <- "OFFSET" skip
INTEGER <- [0-9]+ skip
CONSTRUCT <- "CONSTRUCT" skip
DESCRIBE <- "DESCRIBE" skip
ASK <- "ASK" skip
OR <- "||" skip
AND <- "&&" skip
EQ <- '=' skip
NE <- '!=' skip
GT <- '>' skip
LT <- '<' skip
LE <- '<=' skip
GE <- '>=' skip
IN <- "in" skip
NOTIN <- "not in" skip
AS <- "AS" skip
STR <- "STR" skip
LANG <- "LANG" skip
DATATYPE <- "DATATYPE" skip
IRI <- "IRI" skip
URI <- "URI" skip
ABS <- "ABS" skip
CEIL <- "CEIL" skip
ROUND <- "ROUND" skip
FLOOR <- "FLOOR" skip
STRLEN <- "STRLEN" skip
UCASE <- "UCASE" skip
LCASE <- "LCASE" skip
ENCODEFORURI <- "ENCODE_FOR_URI" skip
YEAR <- "YEAR" skip
MONTH <- "MONTH" skip
DAY <- "DAY" skip
HOURS <- "HOURS" skip
MINUTES <- "MINUTES" skip
SECONDS <- "SECONDS" skip
TIMEZONE <- "TIMEZONE" skip
TZ <- "TZ" skip
MD5 <- "MD" skip
SHA1 <- "SHA1" skip
SHA256 <- "SHA256" skip
SHA384 <- "SHA384" skip
SHA512 <- "SHA512" skip
ISIRI <- "ISIRI" skip
ISURI <- "ISURI" skip
ISBLANK <- "ISBLANK" skip
ISLITERAL <- "ISLITERAL" skip
ISNUMERIC <-"ISNUMERIC" skip
LANGMATCHES <- "LANGMATCHES" skip
CONTAINS <- "CONTAINS" skip
STRSTARTS <- "STRSTARTS" skip
STRENDS <- "STRENDS" skip
STRBEFORE <- "STRBEFORE" skip
STRAFTER <- "STRAFTER" skip
STRLANG <- "STRLANG" skip
STRDT <- "STRDT" skip
SAMETERM <- "SAMETERM" skip
BOUND <- "BOUND" skip
BNODE <- "BNODE" skip
RAND <- "RAND" skip
NOW <- "NOW" skip
UUID <- "UUID" skip
STRUUID <- "STRUUID" skip
CONCAT <- "CONCAT" skip
SUBSTR <- "SUBSTR" skip
REPLACE <- "REPLACE" skip
REGEX <- "REGEX" skip
IF <- "IF" skip
EXISTS <- "EXISTS" skip
NOTEXIST <- "NOT EXISTS" skip
COALESCE <- "COALESCE" skip

skip <- ( ws / comment )*

ws <- '\040' / '\t' / '\f' / '\v' / endOfLine

comment <- '#' (!endOfLine .)* endOfLine

endOfLine <- '\r\n' / '\n' / '\r'


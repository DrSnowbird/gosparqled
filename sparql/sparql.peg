# SPARQL grammar

package sparql

type Sparql Peg {
}

queryContainer <- skip prolog query !.

prolog <- ( prefixDecl / baseDecl )*

prefixDecl <- PREFIX [^: ]* COLON iri

baseDecl <- BASE iri

query <- selectQuery / constructQuery / describeQuery / askQuery
selectQuery <- select datasetClause? whereClause solutionModifier
select <- SELECT ( DISTINCT / REDUCED )? ( STAR / projectionElem+ )
subSelect <- select whereClause
constructQuery <- construct datasetClause? whereClause solutionModifier
construct <- CONSTRUCT LBRACE triplesBlock? RBRACE
describeQuery <- describe datasetClause? whereClause? solutionModifier
describe <- DESCRIBE ( STAR / var / iriref )
askQuery <- ASK datasetClause? whereClause

projectionElem <- var / LPAREN expression AS var RPAREN

datasetClause <- FROM NAMED? iriref

whereClause <- WHERE? groupGraphPattern

groupGraphPattern <- LBRACE ( subSelect / graphPattern ) RBRACE

graphPattern <- basicGraphPattern? ( graphPatternNotTriples DOT? graphPattern )?

graphPatternNotTriples <- optionalGraphPattern / groupOrUnionGraphPattern

optionalGraphPattern <- OPTIONAL LBRACE ( subSelect / graphPattern ) RBRACE

groupOrUnionGraphPattern <- groupGraphPattern ( UNION groupOrUnionGraphPattern )?

basicGraphPattern <- triplesBlock

triplesBlock <- triplesSameSubjectPath ( DOT triplesSameSubjectPath )* DOT?

triplesSameSubjectPath <- ( varOrTerm propertyListPath / triplesNodePath propertyListPath )

varOrTerm <- var / graphTerm

graphTerm <- iriref / literal / numericLiteral / booleanLiteral / blankNode / nil

triplesNodePath <- collectionPath / blankNodePropertyListPath

collectionPath <- LPAREN graphNodePath+ RPAREN

blankNodePropertyListPath <- LBRACK propertyListPath RBRACK

propertyListPath <- ( var / verbPath ) objectListPath ( SEMICOLON propertyListPath )?

verbPath <- path

path <- pathAlternative

pathAlternative <- pathSequence ( PIPE pathAlternative )*

pathSequence <- pathElt ( SLASH pathSequence )*

# TODO: support pathmod rule.
pathElt <- INVERSE? pathPrimary #pathMod?

pathPrimary <- iriref / ISA / NOT pathNegatedPropertySet / LPAREN path RPAREN

pathNegatedPropertySet <- pathOneInPropertySet / LPAREN ( pathOneInPropertySet ( PIPE pathOneInPropertySet )* )? RPAREN

pathOneInPropertySet <- iriref / ISA / INVERSE ( iriref / ISA )

#pathMod <- STAR / QUESTION / PLUS

objectListPath <- objectPath ( COMMA objectListPath )*

objectPath <- graphNodePath

graphNodePath <- varOrTerm

solutionModifier <- limitOffsetClauses?

limitOffsetClauses <- limit offset? / offset limit?

limit <- LIMIT INTEGER

offset <- OFFSET INTEGER

# Expressions

expression <- conditionalOrExpression
conditionalOrExpression <- conditionalAndExpression ( OR conditionalOrExpression )?
conditionalAndExpression <- valueLogical ( AND conditionalAndExpression )?
valueLogical <- numericExpression ( ( EQ / NE / LT / LE / GE / GT ) numericExpression / in / notin )?
numericExpression <- multiplicativeExpression ( ( PLUS / MINUS ) multiplicativeExpression / signedNumericLiteral )*
multiplicativeExpression <- unaryExpression ( ( STAR / SLASH ) unaryExpression )*
unaryExpression <- ( NOT / MINUS / PLUS )? primaryExpression
primaryExpression <- brackettedExpression / iriref / literal / numericLiteral / booleanLiteral / var
brackettedExpression <- LPAREN expression RPAREN

in <- IN argList
notin <- NOTIN argList

argList <- nil / LPAREN expression ( COMMA expression )* RPAREN

#
# Terminals
#

var <- ('?' / '$') VARNAME skip

iriref <- iri / prefixedName

iri <- '<' [^>]* '>' skip

prefixedName <- [^: ]* ':' [a-zA-Z0-9.-_:%]* skip

literal <- string ( '@' [[a-z]]+ ('-' ([[a-z]] / [0-9])+)* / "^^" iriref )? skip

string <- '\"' [^"]* '\"'

numericLiteral <- ('+' / '-')? [0-9]+ ('.' [0-9]*)? skip
signedNumericLiteral <- ('+' / '-') [0-9]+ ('.' [0-9]*)? skip

booleanLiteral <- TRUE / FALSE

blankNode <- blankNodeLabel / anon

blankNodeLabel <- "_:" [a-zA-Z0-9][a-zA-Z0-9.-_] ?skip

anon <- '[' ws* ']' skip

nil <- '(' ws* ')' skip

#
# Labels
#

VARNAME <- ( PN_CHARS_U / [0-9] )+ 
PN_CHARS_U <- PN_CHARS_BASE / '_'
PN_CHARS_BASE <- [[a-z]]

#
# Tokens
#

PREFIX <- "PREFIX" skip
TRUE <- "TRUE" skip
FALSE <- "FALSE" skip
BASE <- "BASE" skip
SELECT <- "SELECT" skip
REDUCED <- "REDUCED" skip
DISTINCT <- "DISTINCT" skip
FROM <- "FROM" skip
NAMED <- "NAMED" skip
WHERE <- "WHERE" skip
LBRACE <- '{' skip
RBRACE <- '}' skip
LBRACK <- '[' skip
RBRACK <- ']' skip
SEMICOLON <- ';' skip
COMMA <- ',' skip
DOT <- '.' skip
COLON <- ':' skip
PIPE <- '|' skip
SLASH <- '/' skip
INVERSE <- '^' skip
LPAREN <- '(' skip
RPAREN <- ')' skip
ISA <- 'a' skip
NOT <- '!' skip
STAR <- '*' skip
#QUESTION <- '?' skip
PLUS <- '+' skip
MINUS <- '-' skip
OPTIONAL <- "OPTIONAL" skip
UNION <- "UNION" skip
LIMIT <- "LIMIT" skip
OFFSET <- "OFFSET" skip
INTEGER <- [0-9]+ skip
CONSTRUCT <- "CONSTRUCT" skip
DESCRIBE <- "DESCRIBE" skip
ASK <- "ASK" skip
OR <- "||" skip
AND <- "&&" skip
EQ <- '=' skip
NE <- '!=' skip
GT <- '>' skip
LT <- '<' skip
LE <- '<=' skip
GE <- '>=' skip
IN <- "in" skip
NOTIN <- "not in" skip
AS <- "AS" skip

skip <- ( ws / comment )*

ws <- '\040' / '\t' / '\f' / '\v' / endOfLine

comment <- '#' (!endOfLine .)* endOfLine

endOfLine <- '\r\n' / '\n' / '\r'


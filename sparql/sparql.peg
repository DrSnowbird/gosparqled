# SPARQL grammar

package sparql

type Sparql Peg {
}

queryContainer <- ws prolog query !.

prolog <- ( prefixDecl / baseDecl )*

prefixDecl <- PREFIX [^: ]* COLON iri

baseDecl <- BASE iri

query <- selectQuery / constructQuery / describeQuery / askQuery
selectQuery <- select datasetClause? whereClause solutionModifier
select <- SELECT ( DISTINCT / REDUCED )? ( STAR / projectionElem+ )
subSelect <- select whereClause
constructQuery <- construct datasetClause? whereClause solutionModifier
construct <- CONSTRUCT LBRACE triplesBlock? RBRACE
describeQuery <- describe datasetClause? whereClause? solutionModifier
describe <- DESCRIBE ( STAR / var / iriref )
askQuery <- ASK datasetClause? whereClause

projectionElem <- var / LPAREN expression AS var RPAREN

datasetClause <- FROM NAMED? iriref

whereClause <- WHERE? groupGraphPattern

groupGraphPattern <- LBRACE ( subSelect / graphPattern ) RBRACE

graphPattern <- basicGraphPattern? ( graphPatternNotTriples DOT? graphPattern )?

graphPatternNotTriples <- optionalGraphPattern / groupOrUnionGraphPattern

optionalGraphPattern <- OPTIONAL LBRACE ( subSelect / graphPattern ) RBRACE

groupOrUnionGraphPattern <- groupGraphPattern ( UNION groupOrUnionGraphPattern )?

basicGraphPattern <- triplesBlock

triplesBlock <- triplesSameSubjectPath ( DOT triplesSameSubjectPath )* DOT?

triplesSameSubjectPath <- ( varOrTerm propertyListPath / triplesNodePath propertyListPath )

varOrTerm <- var / graphTerm

graphTerm <- iriref / literal / numericLiteral / booleanLiteral / blankNode / nil

triplesNodePath <- collectionPath / blankNodePropertyListPath

collectionPath <- LPAREN graphNodePath+ RPAREN

blankNodePropertyListPath <- LBRACK propertyListPath RBRACK

propertyListPath <- ( var / verbPath ) objectListPath ( SEMICOLON propertyListPath )?

verbPath <- path

path <- pathAlternative

pathAlternative <- pathSequence ( PIPE pathAlternative )*

pathSequence <- pathElt ( SLASH pathSequence )*

# TODO: support pathmod rule.
pathElt <- INVERSE? pathPrimary #pathMod?

pathPrimary <- iriref / ISA / NOT pathNegatedPropertySet / LPAREN path RPAREN

pathNegatedPropertySet <- pathOneInPropertySet / LPAREN ( pathOneInPropertySet ( PIPE pathOneInPropertySet )* )? RPAREN

pathOneInPropertySet <- iriref / ISA / INVERSE ( iriref / ISA )

#pathMod <- STAR / QUESTION / PLUS

objectListPath <- objectPath ( COMMA objectListPath )*

objectPath <- graphNodePath

graphNodePath <- varOrTerm

solutionModifier <- limitOffsetClauses?

limitOffsetClauses <- limit offset? / offset limit?

limit <- LIMIT INTEGER

offset <- OFFSET INTEGER

# Expressions

expression <- conditionalOrExpression
conditionalOrExpression <- conditionalAndExpression ( OR conditionalOrExpression )?
conditionalAndExpression <- valueLogical ( AND conditionalAndExpression )?
valueLogical <- numericExpression ( ( EQ / NE / LT / LE / GE / GT ) numericExpression / in / notin )?
numericExpression <- multiplicativeExpression ( ( PLUS / MINUS ) multiplicativeExpression / signedNumericLiteral )*
multiplicativeExpression <- unaryExpression ( ( STAR / SLASH ) unaryExpression )*
unaryExpression <- ( NOT / MINUS / PLUS )? primaryExpression
primaryExpression <- brackettedExpression / iriref / literal / numericLiteral / booleanLiteral / var
brackettedExpression <- LPAREN expression RPAREN

in <- IN argList
notin <- NOTIN argList

argList <- nil / LPAREN expression ( COMMA expression )* RPAREN

#
# Terminals
#

var <- ('?' / '$') VARNAME ws

iriref <- iri / prefixedName

iri <- '<' [^>]* '>' ws

prefixedName <- [^: ]* ':' [a-zA-Z0-9.-_:%]* ws

literal <- string ( '@' [[a-z]]+ ('-' ([[a-z]] / [0-9])+)* / "^^" iriref )? ws

string <- '\"' [^"]* '\"'

numericLiteral <- ('+' / '-')? [0-9]+ ('.' [0-9]*)? ws
signedNumericLiteral <- ('+' / '-') [0-9]+ ('.' [0-9]*)? ws

booleanLiteral <- TRUE / FALSE

blankNode <- blankNodeLabel / anon

blankNodeLabel <- "_:" [a-zA-Z0-9][a-zA-Z0-9.-_] ?ws

anon <- '[' ws ']' ws

nil <- '(' ws ')' ws

#
# Labels
#

VARNAME <- ( PN_CHARS_U / [0-9] )+ 
PN_CHARS_U <- PN_CHARS_BASE / '_'
PN_CHARS_BASE <- [[a-z]]

#
# Tokens
#

PREFIX <- "PREFIX" ws
TRUE <- "TRUE" ws
FALSE <- "FALSE" ws
BASE <- "BASE" ws
SELECT <- "SELECT" ws
REDUCED <- "REDUCED" ws
DISTINCT <- "DISTINCT" ws
FROM <- "FROM" ws
NAMED <- "NAMED" ws
WHERE <- "WHERE" ws
LBRACE <- '{' ws
RBRACE <- '}' ws
LBRACK <- '[' ws
RBRACK <- ']' ws
SEMICOLON <- ';' ws
COMMA <- ',' ws
DOT <- '.' ws
COLON <- ':' ws
PIPE <- '|' ws
SLASH <- '/' ws
INVERSE <- '^' ws
LPAREN <- '(' ws
RPAREN <- ')' ws
ISA <- 'a' ws
NOT <- '!' ws
STAR <- '*' ws
#QUESTION <- '?' ws
PLUS <- '+' ws
MINUS <- '-' ws
OPTIONAL <- "OPTIONAL" ws
UNION <- "UNION" ws
LIMIT <- "LIMIT" ws
OFFSET <- "OFFSET" ws
INTEGER <- [0-9]+ ws
CONSTRUCT <- "CONSTRUCT" ws
DESCRIBE <- "DESCRIBE" ws
ASK <- "ASK" ws
OR <- "||" ws
AND <- "&&" ws
EQ <- '=' ws
NE <- '!=' ws
GT <- '>' ws
LT <- '<' ws
LE <- '<=' ws
GE <- '>=' ws
IN <- "in" ws
NOTIN <- "not in" ws
AS <- "AS" ws

ws <- ( '\040' / '\t' / '\r' / '\n' / '\f' / '\v' )*

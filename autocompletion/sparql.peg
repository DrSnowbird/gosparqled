# SPARQL grammar modified to support auto-completion

package autocompletion

type Sparql Peg {
    *Scope
}

queryContainer <- skip prolog query !.

prolog <- ( prefixDecl / baseDecl )*

prefixDecl <- PREFIX <[^: ]* COLON iri> { p.addPrefix(p.skipComment(buffer, begin, end)) }

baseDecl <- BASE iri

query <- selectQuery / constructQuery / describeQuery / askQuery
selectQuery <- select datasetClause? whereClause solutionModifier
select <- SELECT ( DISTINCT / REDUCED )? ( STAR / projectionElem+ )
subSelect <- select whereClause
constructQuery <- construct datasetClause? whereClause solutionModifier
construct <- CONSTRUCT LBRACE triplesBlock? RBRACE
describeQuery <- describe datasetClause? whereClause? solutionModifier
describe <- DESCRIBE ( STAR / var / iriref )
askQuery <- ASK datasetClause? whereClause

projectionElem <- var / LPAREN expression AS var RPAREN

datasetClause <- FROM NAMED? iriref

whereClause <- WHERE? groupGraphPattern

groupGraphPattern <- LBRACE ( subSelect / graphPattern ) RBRACE

graphPattern <- basicGraphPattern? ( graphPatternNotTriples DOT? graphPattern )?

graphPatternNotTriples <- optionalGraphPattern / groupOrUnionGraphPattern

optionalGraphPattern <- OPTIONAL LBRACE ( subSelect / graphPattern ) RBRACE

groupOrUnionGraphPattern <- groupGraphPattern ( UNION groupOrUnionGraphPattern )?

basicGraphPattern <- triplesBlock

triplesBlock <- triplesSameSubjectPath ( DOT triplesSameSubjectPath )* DOT?

triplesSameSubjectPath <- ( varOrTerm propertyListPath / triplesNodePath propertyListPath )

varOrTerm <- <var> { p.setSubject(p.skipComment(buffer, begin, end)) } / <graphTerm> { p.setSubject(p.skipComment(buffer, begin, end)) } / pof { p.setSubject("?POF") } 

graphTerm <- iriref / literal / numericLiteral / booleanLiteral / blankNode / nil

triplesNodePath <- collectionPath / blankNodePropertyListPath

collectionPath <- LPAREN graphNodePath+ RPAREN

blankNodePropertyListPath <- LBRACK propertyListPath RBRACK

propertyListPath <- ( pof { p.setPredicate("?POF") } / <var> { p.setPredicate(p.skipComment(buffer, begin, end)) } / verbPath ) objectListPath ( SEMICOLON propertyListPath )?

verbPath <- path

path <- pathAlternative

pathAlternative <- pathSequence ( PIPE pathAlternative )*

pathSequence <- <pathElt> { p.setPredicate(p.skipComment(buffer, begin, end)) } ( SLASH pathSequence )*

# TODO: support pathmod rule.
pathElt <- INVERSE? pathPrimary #pathMod?

pathPrimary <- iriref / ISA / NOT pathNegatedPropertySet / LPAREN path RPAREN

pathNegatedPropertySet <- pathOneInPropertySet / LPAREN ( pathOneInPropertySet ( PIPE pathOneInPropertySet )* )? RPAREN

pathOneInPropertySet <- iriref / ISA / INVERSE ( iriref / ISA )

#pathMod <- STAR / QUESTION / PLUS

objectListPath <- objectPath ( COMMA objectListPath )*

objectPath <- pof { p.setObject("?POF"); p.addTriplePattern() } / <graphNodePath> { p.setObject(p.skipComment(buffer, begin, end)); p.addTriplePattern() } / { p.setObject("?FillVar"); p.addTriplePattern() }

graphNodePath <- var / graphTerm

solutionModifier <- limitOffsetClauses?

limitOffsetClauses <- limit offset? / offset limit?

limit <- LIMIT INTEGER

offset <- OFFSET INTEGER

# Expressions

expression <- conditionalOrExpression
conditionalOrExpression <- conditionalAndExpression ( OR conditionalOrExpression )?
conditionalAndExpression <- valueLogical ( AND conditionalAndExpression )?
valueLogical <- numericExpression ( ( EQ / NE / LT / LE / GE / GT ) numericExpression / in / notin )?
numericExpression <- multiplicativeExpression ( ( PLUS / MINUS ) multiplicativeExpression / signedNumericLiteral )*
multiplicativeExpression <- unaryExpression ( ( STAR / SLASH ) unaryExpression )*
unaryExpression <- ( NOT / MINUS / PLUS )? primaryExpression
primaryExpression <- brackettedExpression / iriref / literal / numericLiteral / booleanLiteral / var
brackettedExpression <- LPAREN expression RPAREN

in <- IN argList
notin <- NOTIN argList

argList <- nil / LPAREN expression ( COMMA expression )* RPAREN

#
# Point Of Focus
#

pof <- (
        <[[a-z]]*>':' { p.setPrefix(p.skipComment(buffer, begin, end)) } /
        <[2-9][0-9]*>'/' { p.setPathLength(p.skipComment(buffer, begin, end)) } /
        <[a-zA-Z0-9.\-_+]*> { p.setKeyword(p.skipComment(buffer, begin, end)) }
       ) '<' ws skip

#
# Terminals
#

var <- ('?' / '$') VARNAME skip

iriref <- iri / prefixedName

iri <- '<' [^>]* '>' skip

prefixedName <- [^: ]* ':' [a-zA-Z0-9.-_:%]* skip

literal <- string ( '@' [[a-z]]+ ('-' ([[a-z]] / [0-9])+)* / "^^" iriref )? skip

string <- '\"' [^"]* '\"'

numericLiteral <- ('+' / '-')? [0-9]+ ('.' [0-9]*)? skip
signedNumericLiteral <- ('+' / '-') [0-9]+ ('.' [0-9]*)? skip

booleanLiteral <- TRUE / FALSE

blankNode <- blankNodeLabel / anon

blankNodeLabel <- "_:" [a-zA-Z0-9][a-zA-Z0-9.-_] ?skip

anon <- '[' ws* ']' skip

nil <- '(' ws* ')' skip

#
# Labels
#

VARNAME <- ( PN_CHARS_U / [0-9] )+ 
PN_CHARS_U <- PN_CHARS_BASE / '_'
PN_CHARS_BASE <- [[a-z]]

#
# Tokens
#

PREFIX <- "PREFIX" skip
TRUE <- "TRUE" skip
FALSE <- "FALSE" skip
BASE <- "BASE" skip
SELECT <- "SELECT" skip
REDUCED <- "REDUCED" skip
DISTINCT <- "DISTINCT" skip
FROM <- "FROM" skip
NAMED <- "NAMED" skip
WHERE <- "WHERE" skip
LBRACE <- '{' skip
RBRACE <- '}' skip
LBRACK <- '[' skip
RBRACK <- ']' skip
SEMICOLON <- ';' skip
COMMA <- ',' skip
DOT <- '.' skip
COLON <- ':' skip
PIPE <- '|' skip
SLASH <- '/' skip
INVERSE <- '^' skip
LPAREN <- '(' skip
RPAREN <- ')' skip
ISA <- 'a' skip
NOT <- '!' skip
STAR <- '*' skip
#QUESTION <- '?' skip
PLUS <- '+' skip
MINUS <- '-' skip
OPTIONAL <- "OPTIONAL" skip
UNION <- "UNION" skip
LIMIT <- "LIMIT" skip
OFFSET <- "OFFSET" skip
INTEGER <- [0-9]+ skip
CONSTRUCT <- "CONSTRUCT" skip
DESCRIBE <- "DESCRIBE" skip
ASK <- "ASK" skip
OR <- "||" skip
AND <- "&&" skip
EQ <- '=' skip
NE <- '!=' skip
GT <- '>' skip
LT <- '<' skip
LE <- '<=' skip
GE <- '>=' skip
IN <- "in" skip
NOTIN <- "not in" skip
AS <- "AS" skip

skip <- ( ws / comment )*

ws <- '\040' / '\t' / '\f' / '\v' / endOfLine

comment <- < '#' (!endOfLine .)* endOfLine > { p.commentBegin = begin }

endOfLine <- '\r\n' / '\n' / '\r'

